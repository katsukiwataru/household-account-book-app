// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `
  type AggregateProduct {
    count: Int!
  }

  type AggregateUser {
    count: Int!
  }

  type BatchPayload {
    count: Long!
  }

  scalar Long

  type Mutation {
    createProduct(data: ProductCreateInput!): Product!
    updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
    updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
    upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
    deleteProduct(where: ProductWhereUniqueInput!): Product
    deleteManyProducts(where: ProductWhereInput): BatchPayload!
    createUser(data: UserCreateInput!): User!
    updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
    updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
    upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
    deleteUser(where: UserWhereUniqueInput!): User
    deleteManyUsers(where: UserWhereInput): BatchPayload!
  }

  enum MutationType {
    CREATED
    UPDATED
    DELETED
  }

  interface Node {
    id: ID!
  }

  type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
  }

  type Product {
    id: ID!
    name: String!
    price: Int!
  }

  type ProductConnection {
    pageInfo: PageInfo!
    edges: [ProductEdge]!
    aggregate: AggregateProduct!
  }

  input ProductCreateInput {
    id: ID
    name: String!
    price: Int!
  }

  input ProductCreateManyInput {
    create: [ProductCreateInput!]
    connect: [ProductWhereUniqueInput!]
  }

  type ProductEdge {
    node: Product!
    cursor: String!
  }

  enum ProductOrderByInput {
    id_ASC
    id_DESC
    name_ASC
    name_DESC
    price_ASC
    price_DESC
  }

  type ProductPreviousValues {
    id: ID!
    name: String!
    price: Int!
  }

  input ProductScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    name: String
    name_not: String
    name_in: [String!]
    name_not_in: [String!]
    name_lt: String
    name_lte: String
    name_gt: String
    name_gte: String
    name_contains: String
    name_not_contains: String
    name_starts_with: String
    name_not_starts_with: String
    name_ends_with: String
    name_not_ends_with: String
    price: Int
    price_not: Int
    price_in: [Int!]
    price_not_in: [Int!]
    price_lt: Int
    price_lte: Int
    price_gt: Int
    price_gte: Int
    AND: [ProductScalarWhereInput!]
    OR: [ProductScalarWhereInput!]
    NOT: [ProductScalarWhereInput!]
  }

  type ProductSubscriptionPayload {
    mutation: MutationType!
    node: Product
    updatedFields: [String!]
    previousValues: ProductPreviousValues
  }

  input ProductSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: ProductWhereInput
    AND: [ProductSubscriptionWhereInput!]
    OR: [ProductSubscriptionWhereInput!]
    NOT: [ProductSubscriptionWhereInput!]
  }

  input ProductUpdateDataInput {
    name: String
    price: Int
  }

  input ProductUpdateInput {
    name: String
    price: Int
  }

  input ProductUpdateManyDataInput {
    name: String
    price: Int
  }

  input ProductUpdateManyInput {
    create: [ProductCreateInput!]
    update: [ProductUpdateWithWhereUniqueNestedInput!]
    upsert: [ProductUpsertWithWhereUniqueNestedInput!]
    delete: [ProductWhereUniqueInput!]
    connect: [ProductWhereUniqueInput!]
    set: [ProductWhereUniqueInput!]
    disconnect: [ProductWhereUniqueInput!]
    deleteMany: [ProductScalarWhereInput!]
    updateMany: [ProductUpdateManyWithWhereNestedInput!]
  }

  input ProductUpdateManyMutationInput {
    name: String
    price: Int
  }

  input ProductUpdateManyWithWhereNestedInput {
    where: ProductScalarWhereInput!
    data: ProductUpdateManyDataInput!
  }

  input ProductUpdateWithWhereUniqueNestedInput {
    where: ProductWhereUniqueInput!
    data: ProductUpdateDataInput!
  }

  input ProductUpsertWithWhereUniqueNestedInput {
    where: ProductWhereUniqueInput!
    update: ProductUpdateDataInput!
    create: ProductCreateInput!
  }

  input ProductWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    name: String
    name_not: String
    name_in: [String!]
    name_not_in: [String!]
    name_lt: String
    name_lte: String
    name_gt: String
    name_gte: String
    name_contains: String
    name_not_contains: String
    name_starts_with: String
    name_not_starts_with: String
    name_ends_with: String
    name_not_ends_with: String
    price: Int
    price_not: Int
    price_in: [Int!]
    price_not_in: [Int!]
    price_lt: Int
    price_lte: Int
    price_gt: Int
    price_gte: Int
    AND: [ProductWhereInput!]
    OR: [ProductWhereInput!]
    NOT: [ProductWhereInput!]
  }

  input ProductWhereUniqueInput {
    id: ID
  }

  type Query {
    product(where: ProductWhereUniqueInput!): Product
    products(
      where: ProductWhereInput
      orderBy: ProductOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Product]!
    productsConnection(
      where: ProductWhereInput
      orderBy: ProductOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): ProductConnection!
    user(where: UserWhereUniqueInput!): User
    users(
      where: UserWhereInput
      orderBy: UserOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [User]!
    usersConnection(
      where: UserWhereInput
      orderBy: UserOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): UserConnection!
    node(id: ID!): Node
  }

  type Subscription {
    product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
    user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  }

  type User {
    id: ID!
    name: String!
    products(
      where: ProductWhereInput
      orderBy: ProductOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Product!]
  }

  type UserConnection {
    pageInfo: PageInfo!
    edges: [UserEdge]!
    aggregate: AggregateUser!
  }

  input UserCreateInput {
    id: ID
    name: String!
    products: ProductCreateManyInput
  }

  type UserEdge {
    node: User!
    cursor: String!
  }

  enum UserOrderByInput {
    id_ASC
    id_DESC
    name_ASC
    name_DESC
  }

  type UserPreviousValues {
    id: ID!
    name: String!
  }

  type UserSubscriptionPayload {
    mutation: MutationType!
    node: User
    updatedFields: [String!]
    previousValues: UserPreviousValues
  }

  input UserSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: UserWhereInput
    AND: [UserSubscriptionWhereInput!]
    OR: [UserSubscriptionWhereInput!]
    NOT: [UserSubscriptionWhereInput!]
  }

  input UserUpdateInput {
    name: String
    products: ProductUpdateManyInput
  }

  input UserUpdateManyMutationInput {
    name: String
  }

  input UserWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    name: String
    name_not: String
    name_in: [String!]
    name_not_in: [String!]
    name_lt: String
    name_lte: String
    name_gt: String
    name_gte: String
    name_contains: String
    name_not_contains: String
    name_starts_with: String
    name_not_starts_with: String
    name_ends_with: String
    name_not_ends_with: String
    products_every: ProductWhereInput
    products_some: ProductWhereInput
    products_none: ProductWhereInput
    AND: [UserWhereInput!]
    OR: [UserWhereInput!]
    NOT: [UserWhereInput!]
  }

  input UserWhereUniqueInput {
    id: ID
  }
`;
